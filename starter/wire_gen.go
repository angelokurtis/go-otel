// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package otel

import (
	"context"
	"github.com/angelokurtis/go-otel/starter/internal/env"
	"github.com/angelokurtis/go-otel/starter/internal/logger"
	"github.com/angelokurtis/go-otel/starter/internal/metric"
	"github.com/angelokurtis/go-otel/starter/internal/trace"
)

// Injectors from wire_inj.go:

func NewManager(ctx context.Context) (*Manager, func(), error) {
	resource, err := trace.NewResource(ctx)
	if err != nil {
		return nil, nil, err
	}

	variables, err := env.LookupVariables()
	if err != nil {
		return nil, nil, err
	}

	sampler := env.ToTraceSampler(variables)
	samplerArg := env.ToTraceSamplerArg(variables)
	samplerOptions := trace.SamplerOptions{
		Sampler:    sampler,
		SamplerArg: samplerArg,
	}

	traceSampler, err := trace.NewSampler(samplerOptions)
	if err != nil {
		return nil, nil, err
	}

	exporters := env.ToTraceExporters(variables)
	protocol := env.ToTraceProtocol(variables)
	endpoint := env.ToTraceEndpoint(variables)
	compression := env.ToTraceCompression(variables)
	clientOptions := trace.ClientOptions{
		Protocol:    protocol,
		Endpoint:    endpoint,
		Compression: compression,
	}

	client, err := trace.NewClient(clientOptions)
	if err != nil {
		return nil, nil, err
	}

	spanExportersOptions := trace.SpanExportersOptions{
		Exporters: exporters,
		Client:    client,
	}

	v, err := trace.NewSpanExporters(ctx, spanExportersOptions)
	if err != nil {
		return nil, nil, err
	}

	batchTimeout := env.ToTraceTimeout(variables)
	propagators := env.ToTracePropagators(variables)
	textMapPropagator := trace.NewTextMapPropagator(propagators)
	logrLogger := logger.New()
	tracerProviderOptions := trace.TracerProviderOptions{
		Resource:     resource,
		Sampler:      traceSampler,
		Exporters:    v,
		BatchTimeout: batchTimeout,
		Propagator:   textMapPropagator,
		Logger:       logrLogger,
	}
	tracerProvider, cleanup := trace.NewTracerProvider(ctx, tracerProviderOptions)
	metricExporters := env.ToMetricExporters(variables)
	metricEndpoint := env.ToMetricEndpoint(variables)
	metricCompression := env.ToMetricCompression(variables)
	exportInterval := env.ToMetricExportInterval(variables)
	metricProtocol := env.ToMetricProtocol(variables)
	readersOptions := metric.ReadersOptions{
		Exporters:      metricExporters,
		Endpoint:       metricEndpoint,
		Compression:    metricCompression,
		ExportInterval: exportInterval,
		Protocol:       metricProtocol,
	}

	v2, err := metric.NewReaders(ctx, readersOptions)
	if err != nil {
		cleanup()
		return nil, nil, err
	}

	meterProviderOptions := metric.MeterProviderOptions{
		Resource:       resource,
		Readers:        v2,
		ExportInterval: exportInterval,
		Logger:         logrLogger,
	}
	meterProvider, cleanup2 := metric.NewMeterProvider(ctx, meterProviderOptions)
	manager := &Manager{
		TracerProvider: tracerProvider,
		MeterProvider:  meterProvider,
	}

	return manager, func() {
		cleanup2()
		cleanup()
	}, nil
}
